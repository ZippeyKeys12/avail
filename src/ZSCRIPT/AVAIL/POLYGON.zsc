enum Av_EOrientation{
    ORI_COLLINEAR,
    ORI_CLOCKWISE,
    ORI_COUNTERCLOCKWISE,
}

class Av_Polygon{
    Array<Av_Edge> Edges;
}

class Av_Edge{
    Vector2 v1, v2;

    static
    Av_Edge Of(Vector2 v1, Vector2 v2){
        let result=new('Av_Edge');
        result.v1=v1;
        result.v2=v2;
        return result;
    }

    // 2D only!!!!!

    static
    bool AreCollinear(Vector2 p1, Vector2 p2, Vector2 p3){
        return !CollinearDeterminant(p1, p2, p3);
    }

    static
    protected
    int CollinearDeterminant(Vector2 p1, Vector2 p2, Vector2 p3){
        return ;
    }

    static
    Av_EOrientation Orientation(Vector2 p1, Vector2 p2, Vector2 p3){
        let d=CollinearDeterminant(p1, p2, p3);
        if(!d)
            return ORI_COLLINEAR;
        else if(d>0)
            return ORI_CLOCKWISE;
        else
            return ORI_COUNTERCLOCKWISE;
    }

    bool IsOn(Vector2 p){
        return (p.x <= max(v1.x, v2.x) && p.x >= min(v1.x, v2.x)
             && p.y <= max(v1.y, v2.y) && p.y >= min(v1.y, v2.y));
    }

    bool SegmentIntersect(Av_Edge other){
        int o1 = Orientation(v1, other.v1, v2       ),
            o2 = Orientation(v1, other.v1, other.v2 ),
            o3 = Orientation(v2, other.v2, v1       ),
            o4 = Orientation(v2, other.v2, other.v1 );
        
        if(o1!=o2 && o3!=o4)
            return true;
        
        let pq1=Of(p1, q1),
            pq2=Of(p2, q2);
        
        return o1==ORI_COLLINEAR && pq1.IsOn(p2)
            || o2==ORI_COLLINEAR && pq1.IsOn(q2)
            || o3==ORI_COLLINEAR && pq2.IsOn(p1)
            || o4==ORI_COLLINEAR && pq2.IsOn(q1);
    }
}