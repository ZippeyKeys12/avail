enum Av_EOrientation{
    ORI_COLLINEAR,
    ORI_CLOCKWISE,
    ORI_COUNTERCLOCKWISE,
}

class Av_Polygon{
    Array<Av_Line> Edges;
}

class Av_Line{
    Vector2 v1, v2;

    static
    Av_Line Of(Vector2 v1, Vector2 v2){
        let result=new('Av_Line');
        result.v1=v1;
        result.v2=v2;
        return result;
    }

    static
    bool AreCollinear(Av_Vector p1, Av_Vector p2, Av_Vector p3){
        if(p1.Size()!=p2.Size() || p1.Size()!=p3.Size())
            return false;
        let matrix=Av_Matrix2.Create(3, p1.Size());
        matrix.SetRow(0, p1);
        matrix.SetRow(1, p2);
        matrix.SetRow(2, p3);
        return matrix.Rank()==1;
    }

    // 2D only!!!!!

    static
    protected
    int CollinearDeterminant(Vector2 p1, Vector2 p2, Vector2 p3){
        return (p2.y-p1.y)*(p3.x-p2.x)
              -(p2.x-p1.x)*(p3.y-p2.y);
    }

    static
    Av_EOrientation Orientation(Vector2 p1, Vector2 p2, Vector2 p3){
        let d=CollinearDeterminant(p1, p2, p3);
        if(!d)
            return ORI_COLLINEAR;
        else if(d>0)
            return ORI_CLOCKWISE;
        else
            return ORI_COUNTERCLOCKWISE;
    }

    bool IsOn(Vector2 p){
        return (p.x<=max(v1.x, v2.x) && p.x>=min(v1.x, v2.x)
             && p.y<=max(v1.y, v2.y) && p.y>=min(v1.y, v2.y));
    }

    bool SegmentIntersect(Av_Line other){
        let p1=other.v1,
            p2=other.v2;
        int o1 = Orientation(v1, p1, v2),
            o2 = Orientation(v1, p1, p2),
            o3 = Orientation(v2, p2, v1),
            o4 = Orientation(v2, p2, p1);
        
        if(o1!=o2 && o3!=o4)
            return true;
        
        let vp1=Of(v1, p1),
            vp2=Of(v2, p2);
        
        return o1==ORI_COLLINEAR && vp1.IsOn(v2)
            || o2==ORI_COLLINEAR && vp1.IsOn(p2)
            || o3==ORI_COLLINEAR && vp2.IsOn(v1)
            || o4==ORI_COLLINEAR && vp2.IsOn(p1);
    }
}